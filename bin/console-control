#!/usr/bin/ruby1.9.1

require "etc"
require "fileutils"

load ENV["CONSOLE_DEFAULT"] || "/etc/default/#{File.basename $0}"

def is_running
	return false unless File.exist? PID_FILE
	pid = File.read(PID_FILE).to_i
	return false unless File.directory? "/proc/#{pid}"
	return false unless File.readlink("/proc/#{pid}/exe") == "/usr/bin/ruby1.9.1"
	return pid
end

def start
	return if is_running
	puts "Starting"
	system *%W[
		/usr/bin/ruby1.9.1 #{SCRIPT} console
		--fork
		--pid-file #{PID_FILE}
		--log-file #{LOG_FILE}
	]
end

def stop
	exit 0 unless pid = is_running
	puts "Stopping"
	Process.kill "KILL", pid
	while File.directory? "/proc/#{pid}"
		sleep 0.1
	end
end

# ensure pid dir exists
PID_DIR = File.dirname PID_FILE
unless File.directory? PID_DIR
	FileUtils.mkdir_p PID_DIR
	FileUtils.chown USER, USER, PID_DIR
	FileUtils.chmod 0755, PID_DIR
end

# set user
pwent = Etc::getpwnam USER
unless pwent.uid == Process.uid
	Process.maxgroups = 1024
	Process::initgroups USER, pwent.gid
	Process::GID::change_privilege pwent.gid
	Process::UID::change_privilege pwent.uid
	ENV["HOME"] = pwent.dir
end

case ARGV[0]

when "start"
	start

when "stop"
	stop

when "status"
	if is_running
		puts "Running"
		exit 0
	else
		puts "Not running"
		exit 1
	end

when "restart"
	stop if is_running
	start

else
	raise "Invalid command #{ARGV[0]}"

end
