#!/usr/bin/env ruby

require "etc"
require "fileutils"

load ENV["CONSOLE_DEFAULT"] || "/etc/default/#{File.basename $0}"

def is_running
	return false unless File.exist? PID_FILE
	pid = File.read(PID_FILE).to_i
	return false unless File.directory? "/proc/#{pid}"
	#return false unless File.readlink("/proc/#{pid}/exe") == "/usr/bin/ruby1.9.1"
	return pid
end

def shell_quote str
	return str.map { |a| shell_quote a }.join(" ") if str.is_a? Array
	return str if str =~ /^[-a-zA-Z0-9_\/:.=@]+$/
	return "'" + str.gsub("'", "'\\\\''") + "'" unless str =~ /'/
	return "\"" + str.gsub("\\", "\\\\\\\\").gsub("\"", "\\\\\"").gsub("`", "\\\\`").gsub("$", "\\\\$") + "\""
end

def start

	return if is_running

	puts "Starting"

	# console command

	console_args = %W[
		#{SCRIPT}
		console
		--fork
		--pid-file #{PID_FILE}
		--log-file #{LOG_FILE}
	]
	console_cmd = shell_quote console_args

	# wrapper command

	rvm_cmd = "source #{RVM_SCRIPT} && rvm use #{RVM_USE}"
	full_cmd = "#{rvm_cmd} && exec #{console_cmd}"

	bash_args = %W[
		exec
		/bin/bash
		-c #{full_cmd}
	]
	bash_cmd = shell_quote bash_args

	# run it

	system bash_cmd

end

def stop
	exit 0 unless pid = is_running
	puts "Stopping"
	Process.kill "KILL", pid
	while File.directory? "/proc/#{pid}"
		sleep 0.1
	end
end

# ensure pid dir exists
PID_DIR = File.dirname PID_FILE
unless File.directory? PID_DIR
	FileUtils.mkdir_p PID_DIR
	FileUtils.chown USER, USER, PID_DIR
	FileUtils.chmod 0755, PID_DIR
end

# set user
pwent = Etc::getpwnam USER
unless pwent.uid == Process.uid
	Process.maxgroups = 1024
	Process::initgroups USER, pwent.gid
	Process::GID::change_privilege pwent.gid
	Process::UID::change_privilege pwent.uid
	ENV["HOME"] = pwent.dir
end

case ARGV[0]

when "start"
	start

when "stop"
	stop

when "status"
	if is_running
		puts "Running"
		exit 0
	else
		puts "Not running"
		exit 1
	end

when "restart"
	stop if is_running
	start

else
	raise "Invalid command #{ARGV[0]}"

end
