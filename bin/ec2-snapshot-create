#!/usr/bin/ruby

script_path = $0
script_path = File.readlink(script_path) while File.symlink?(script_path)
CONFIG = File.expand_path("#{File.dirname(script_path)}/../..")
$LOAD_PATH.unshift "#{CONFIG}/alchemy-hq/ruby"

require "pp"
require "mandar"
require "xml"

exit_code = 0

def debug(msg)
	return unless $stdin.tty?
	$stderr.puts msg
end

parser = XML::Parser.file ARGV[0]
config_elem = parser.parse.root

# iterate accounts
config_elem.find("aws-account").each do |aws_account_elem|
	aws_account_name = aws_account_elem.attributes["name"]
	access_key_id = aws_account_elem.attributes["access-key-id"]
	secret_access_key = aws_account_elem.attributes["secret-access-key"]

	# iterate region
	config_elem.find("ec2-region").each do |ec2_region_elem|
		ec2_region_name = ec2_region_elem.attributes["name"]
		ec2_region_endpoint = ec2_region_elem.attributes["endpoint"]

		# create aws account
		account = Mandar::AWS::Account.new
		account.name = aws_account_name
		account.access_key_id = access_key_id
		account.secret_access_key = secret_access_key

		# create aws client
		aws_client = Mandar::AWS::Client.new account, ec2_region_endpoint, "2010-08-31"
		aws_client.default_prefix = "a"

		# iterate volumes
		account_xp = "@aws-account='#{aws_account_name}'"
		zone_names_xp = "../ec2-availability-zone[@region='#{ec2_region_name}']/@name"
		zone_xp = "@availability-zone = #{zone_names_xp}"
		volumes_xp = "volume[#{account_xp} and #{zone_xp}]"
		config_elem.find(volumes_xp).each do |volume_elem|
			host = volume_elem.attributes["host"]
			volume_id = volume_elem.attributes["volume-id"]

			# create snapshot
			success = false
			3.times do |try|
				begin
					response = aws_client.create_snapshot({
						:volume_id => volume_id,
						:description => "automated backup of #{host}",
					})
					snapshot_id = response.find_first("a:snapshotId").content
					debug "snapshot for #{host} #{volume_id}: #{snapshot_id}"
					success = true
					break
				rescue Timeout::Error => e
					$stderr.puts "error creating snapshot for #{host} #{volume_id}: #{e.message}"
					sleep 1
				rescue => e
					$stderr.puts "error creating snapshot for #{host} #{volume_id}: #{e.message}"
					sleep 1
				end
			end
			unless success
				$stderr.puts "snapshot for #{host} #{volume_id}: FAILED"
				exit_code = 1
			end
		end
	end
end

exit exit_code
